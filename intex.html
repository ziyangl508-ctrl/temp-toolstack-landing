<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { width: 100vw; height: 100vh; display: block; }
        /* 隐藏摄像头预览，保持网页整洁，但仍开启识别 */
        #video-container {
            position: absolute; bottom: 10px; left: 10px;
            width: 120px; height: 90px; border: 1px solid #00aaff;
            opacity: 0.3; transform: scaleX(-1); pointer-events: none;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
    <div id="video-container"><video id="webcam" autoplay playsinline></video></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/math/MeshSurfaceSampler.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 手势状态变量 ---
        let targetSpreadFactor = 0; 
        let currentSpreadFactor = 0; 

        // --- 初始化模型（保持 800 距离和 0.5 缩放） ---
        const loader = new THREE.OBJLoader();
        const modelUrl = 'https://raw.githubusercontent.com/ziyangl508-ctrl/temp-toolstack-landing/main/wanzheng.obj';

        let particleSystem;
        let originalPositions;
        const particleCount = 1000; 

        loader.load(modelUrl, function (object) {
            const finalScale = 0.5; 
            object.scale.set(finalScale, finalScale, finalScale);
            object.updateMatrixWorld(true);

            const sampledVertices = [];
            object.traverse(function (child) {
                if (child.isMesh) {
                    const sampler = new THREE.MeshSurfaceSampler(child).build();
                    const tempPosition = new THREE.Vector3();
                    for (let i = 0; i < particleCount; i++) {
                        sampler.sample(tempPosition);
                        tempPosition.applyMatrix4(child.matrixWorld);
                        sampledVertices.push(tempPosition.x, tempPosition.y, tempPosition.z);
                    }
                }
            });

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(sampledVertices, 3));
            originalPositions = new Float32Array(sampledVertices);

            const material = new THREE.PointsMaterial({
                color: 0x00aaff,
                size: 1.2, 
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            const box = new THREE.Box3().setFromObject(particleSystem);
            const center = box.getCenter(new THREE.Vector3());
            // 保持你要求的 800 距离
            camera.position.set(center.x, center.y, center.z + 800); 
            controls.target.copy(center);
            controls.update();
        });

        // --- AI 手势识别逻辑 ---
        const videoElement = document.getElementById('webcam');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                // 计算大拇指尖(4)和食指尖(8)的距离
                const thumb = landmarks[4];
                const index = landmarks[8];
                const dist = Math.sqrt(Math.pow(thumb.x-index.x,2)+Math.pow(thumb.y-index.y,2));
                
                // 映射手势距离到扩散系数（0.15是张开手掌的阈值，可微调）
                targetSpreadFactor = Math.max(0, (dist - 0.1) * 4); 
            } else {
                targetSpreadFactor = 0;
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        // --- 动画循环（参数与之前完全一致） ---
        const baseShake = 0.15;       
        const maxSpread = 250.0; // 十倍扩散范围
        const shakeSpeed = 0.002;     

        function animate() {
            requestAnimationFrame(animate);
            if (particleSystem && originalPositions) {
                currentSpreadFactor += (targetSpreadFactor - currentSpreadFactor) * 0.08;
                const positions = particleSystem.geometry.attributes.position.array;
                const time = Date.now() * shakeSpeed;
                const amplitude = baseShake + (currentSpreadFactor * maxSpread);

                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] = originalPositions[i] + Math.sin(time + i) * amplitude;
                    positions[i+1] = originalPositions[i+1] + Math.cos(time + i * 1.1) * amplitude;
                    positions[i+2] = originalPositions[i+2] + Math.sin(time + i * 1.2) * amplitude;
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
